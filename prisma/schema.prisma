// Prisma Schema for Waygate
// https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  output   = "../node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
}

// =============================================================================
// ENUMS
// =============================================================================

/// Authentication type for integrations
enum AuthType {
  none
  oauth2
  api_key
  basic
  bearer
  custom_header
}

/// Status of an integration
enum IntegrationStatus {
  draft
  active
  error
  disabled
}

/// Type of stored credential
enum CredentialType {
  oauth2_tokens
  api_key
  basic
  bearer
}

/// Status of stored credentials
enum CredentialStatus {
  active
  expired
  revoked
  needs_reauth
}

/// Status of a connection
enum ConnectionStatus {
  active
  error
  disabled
}

/// HTTP methods for action endpoints
enum HttpMethod {
  GET
  POST
  PUT
  PATCH
  DELETE
}

/// Direction of field mapping transformation
enum MappingDirection {
  input
  output
}

/// Status of a documentation scrape job
enum ScrapeJobStatus {
  PENDING
  CRAWLING
  PARSING
  GENERATING
  COMPLETED
  FAILED
}

/// Type of connector for a connection (platform-owned vs user-owned)
enum ConnectorType {
  platform
  custom
}

/// Source of stored credentials (platform connector vs user-owned)
enum CredentialSource {
  platform
  user_owned
}

/// Status of a platform connector
enum PlatformConnectorStatus {
  active
  suspended
  deprecated
}

/// Health check status for connections
enum HealthCheckStatus {
  healthy // All checks passed
  degraded // Some issues (e.g., expiring credentials, elevated latency)
  unhealthy // Critical issues (e.g., expired credentials, test action failed)
}

/// Health check tier (determines what gets checked)
enum HealthCheckTier {
  credential // Tier 1: Credential-only check (no API calls)
  connectivity // Tier 2: Single test action (1 API call)
  full_scan // Tier 3: All actions tested (multiple API calls)
}

/// Status of reference data items
enum ReferenceDataStatus {
  active // Item exists in external system
  inactive // Item was soft-deleted (removed from external system)
  deleted // Item explicitly deleted by user
}

/// Status of a reference sync job
enum SyncJobStatus {
  pending // Job created, not yet started
  syncing // Job is currently running
  completed // Job finished successfully
  failed // Job failed with error
}

/// How the health check was triggered
enum HealthCheckTrigger {
  scheduled // Triggered by cron job
  manual // Triggered by user from dashboard
}

/// Type of variable value
enum VariableType {
  string
  number
  boolean
  json
}

/// Routing mode for composite tools
enum CompositeToolRoutingMode {
  rule_based
  agent_driven
}

/// Status of a composite tool
enum CompositeToolStatus {
  draft
  active
  disabled
}

/// Type of routing condition for composite tools
enum RoutingConditionType {
  contains
  equals
  matches
  starts_with
  ends_with
}

/// Credential health status for health checks
enum CredentialHealthStatus {
  active // Credentials are valid and not expiring soon
  expiring // Credentials will expire within 1 hour
  expired // Credentials have expired
  missing // No credentials found for connection
}

/// Circuit breaker status
enum CircuitBreakerStatus {
  closed // Normal operation
  open // Circuit is open, failing fast
  half_open // Testing if service has recovered
}

/// Execution mode for agentic tools
enum AgenticToolExecutionMode {
  parameter_interpreter // LLM generates parameters, system executes
  autonomous_agent // LLM autonomously selects and executes tools
}

/// Status of an agentic tool
enum AgenticToolStatus {
  draft
  active
  disabled
}

/// Status of an agentic tool execution
enum AgenticToolExecutionStatus {
  success
  error
  timeout
}

/// Status of a pipeline tool
enum PipelineStatus {
  draft
  active
  disabled
}

/// Tool type for a pipeline step
enum PipelineStepToolType {
  simple
  composite
  agentic
}

/// Error handling strategy for a pipeline step
enum StepOnError {
  fail_pipeline
  continue
  skip_remaining
}

/// Status of a pipeline execution
enum PipelineExecutionStatus {
  running
  completed
  failed
  timeout
  cancelled
}

/// Status of a step execution within a pipeline
enum StepExecutionStatus {
  pending
  running
  completed
  failed
  skipped
}

// =============================================================================
// MODELS
// =============================================================================

/// Multi-tenant accounts - each tenant is an organization/user account
model Tenant {
  id                String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name              String   @db.VarChar(255)
  email             String   @unique @db.VarChar(255)
  waygateApiKeyHash String   @unique @map("waygate_api_key_hash") @db.VarChar(255)
  settings          Json     @default("{}")
  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  // Relations
  integrations           Integration[]
  connections            Connection[]
  integrationCredentials IntegrationCredential[]
  fieldMappings          FieldMapping[]
  requestLogs            RequestLog[]
  scrapeJobs             ScrapeJob[]
  validationFailures     ValidationFailure[]
  healthChecks           HealthCheck[]
  referenceData          ReferenceData[]
  referenceSyncJobs      ReferenceSyncJob[]
  variables              Variable[]
  compositeTools         CompositeTool[]
  agenticTools           AgenticTool[]
  agenticToolExecutions  AgenticToolExecution[]
  pipelines              Pipeline[]
  pipelineExecutions     PipelineExecution[]
  asyncJobs              AsyncJob[]

  @@map("tenants")
}

/// Integration definitions - configured connections to external APIs
model Integration {
  id               String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId         String            @map("tenant_id") @db.Uuid
  name             String            @db.VarChar(255)
  slug             String            @db.VarChar(100)
  description      String?           @db.Text
  documentationUrl String?           @map("documentation_url") @db.Text
  authType         AuthType          @map("auth_type")
  authConfig       Json              @default("{}") @map("auth_config")
  status           IntegrationStatus @default(draft)
  tags             String[]          @default([])
  metadata         Json              @default("{}")
  createdAt        DateTime          @default(now()) @map("created_at")
  updatedAt        DateTime          @updatedAt @map("updated_at")

  // Health check configuration
  // { enabled: boolean, credentialCheckMinutes: number, connectivityCheckHours: number, fullScanEnabled: boolean, testActionId: string? }
  healthCheckConfig Json @default("{\"enabled\": true, \"credentialCheckMinutes\": 15, \"connectivityCheckHours\": 12, \"fullScanEnabled\": false}") @map("health_check_config")

  // Relations
  tenant            Tenant                  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  actions           Action[]
  credentials       IntegrationCredential[]
  connections       Connection[]
  requestLogs       RequestLog[]
  referenceData     ReferenceData[]
  referenceSyncJobs ReferenceSyncJob[]

  // Indexes
  @@unique([tenantId, slug], name: "integrations_tenant_slug_idx")
  @@index([tenantId], name: "integrations_tenant_id_idx")
  @@index([status], name: "integrations_status_idx")
  @@map("integrations")
}

/// Platform-owned OAuth connectors - Waygate's registered OAuth apps with major providers
model PlatformConnector {
  id                    String                  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  providerSlug          String                  @unique @map("provider_slug") @db.VarChar(100)
  displayName           String                  @map("display_name") @db.VarChar(255)
  description           String?                 @db.Text
  logoUrl               String?                 @map("logo_url") @db.Text
  authType              AuthType                @map("auth_type")
  encryptedClientId     Bytes                   @map("encrypted_client_id")
  encryptedClientSecret Bytes                   @map("encrypted_client_secret")
  authorizationUrl      String                  @map("authorization_url") @db.Text
  tokenUrl              String                  @map("token_url") @db.Text
  defaultScopes         String[]                @default([]) @map("default_scopes")
  callbackPath          String                  @map("callback_path") @db.VarChar(255)
  certifications        Json                    @default("{}") // { casa: { status, tier, expiresAt }, appReview: { status, approvedAt } }
  rateLimits            Json                    @default("{}") @map("rate_limits") // { requestsPerMinute, shared }
  status                PlatformConnectorStatus @default(active)
  metadata              Json                    @default("{}")
  createdAt             DateTime                @default(now()) @map("created_at")
  updatedAt             DateTime                @updatedAt @map("updated_at")

  // Relations
  connections Connection[]

  // Indexes
  @@index([status], name: "platform_connectors_status_idx")
  @@map("platform_connectors")
}

/// Connection - links a consuming app to an integration with its own credentials
model Connection {
  id                  String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId            String           @map("tenant_id") @db.Uuid
  integrationId       String           @map("integration_id") @db.Uuid
  name                String           @db.VarChar(255)
  slug                String           @db.VarChar(100)
  baseUrl             String?          @map("base_url") @db.Text
  isPrimary           Boolean          @default(false) @map("is_primary")
  connectorType       ConnectorType    @default(custom) @map("connector_type")
  platformConnectorId String?          @map("platform_connector_id") @db.Uuid
  status              ConnectionStatus @default(active)
  metadata            Json             @default("{}")
  createdAt           DateTime         @default(now()) @map("created_at")
  updatedAt           DateTime         @updatedAt @map("updated_at")

  // Health tracking
  healthStatus            HealthCheckStatus @default(healthy) @map("health_status")
  lastCredentialCheckAt   DateTime?         @map("last_credential_check_at")
  lastConnectivityCheckAt DateTime?         @map("last_connectivity_check_at")
  lastFullScanAt          DateTime?         @map("last_full_scan_at")
  healthCheckTestActionId String?           @map("health_check_test_action_id") @db.Uuid

  // LLM Response Preamble
  preambleTemplate String? @map("preamble_template") @db.Text

  // Relations
  tenant                Tenant                  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  integration           Integration             @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  platformConnector     PlatformConnector?      @relation(fields: [platformConnectorId], references: [id], onDelete: SetNull)
  healthCheckTestAction Action?                 @relation("ConnectionTestAction", fields: [healthCheckTestActionId], references: [id], onDelete: SetNull)
  credentials           IntegrationCredential[]
  requestLogs           RequestLog[]
  healthChecks          HealthCheck[]
  fieldMappings         FieldMapping[]
  referenceData         ReferenceData[]
  referenceSyncJobs     ReferenceSyncJob[]
  variables             Variable[]

  // Indexes
  @@unique([tenantId, integrationId, slug], name: "connections_tenant_integration_slug_idx")
  @@index([tenantId], name: "connections_tenant_id_idx")
  @@index([integrationId], name: "connections_integration_id_idx")
  @@index([platformConnectorId], name: "connections_platform_connector_id_idx")
  @@index([status], name: "connections_status_idx")
  @@index([healthStatus], name: "connections_health_status_idx")
  @@map("connections")
}

/// Action definitions - typed operations within an integration
model Action {
  id               String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  integrationId    String     @map("integration_id") @db.Uuid
  name             String     @db.VarChar(255)
  slug             String     @db.VarChar(100)
  description      String?    @db.Text
  httpMethod       HttpMethod @map("http_method")
  endpointTemplate String     @map("endpoint_template") @db.Text
  inputSchema      Json       @default("{}") @map("input_schema")
  outputSchema     Json       @default("{}") @map("output_schema")
  paginationConfig Json?      @map("pagination_config")
  validationConfig Json?      @map("validation_config")
  retryConfig      Json?      @map("retry_config")
  cacheable        Boolean    @default(false)
  cacheTtlSeconds  Int?       @map("cache_ttl_seconds")
  tags             String[]   @default([])
  metadata         Json       @default("{}")
  createdAt        DateTime   @default(now()) @map("created_at")
  updatedAt        DateTime   @updatedAt @map("updated_at")

  // AI Tool Export configuration (LLM-generated at action creation time)
  toolDescription     String? @map("tool_description") @db.Text /// LLM-optimized mini-prompt description for AI agents
  toolSuccessTemplate String? @map("tool_success_template") @db.Text /// Template for formatting successful tool responses
  toolErrorTemplate   String? @map("tool_error_template") @db.Text /// Template for formatting error responses

  // Batch Operations configuration
  batchEnabled Boolean @default(false) @map("batch_enabled") /// Whether this action supports batch processing
  batchConfig  Json?   @map("batch_config") /// Batch behavior: maxItems, defaultConcurrency, defaultDelayMs, toolDescription
  bulkConfig   Json?   @map("bulk_config") /// Optional bulk API routing: endpoint, httpMethod, payloadTransform, responseMapping

  // Relations
  integration              Integration              @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  fieldMappings            FieldMapping[]
  requestLogs              RequestLog[]
  validationFailures       ValidationFailure[]
  connectionTestActionFor  Connection[]             @relation("ConnectionTestAction")
  healthChecksAsTestAction HealthCheck[]            @relation("HealthCheckTestAction")
  referenceDataSyncedBy    ReferenceData[]
  compositeToolOperations  CompositeToolOperation[]

  // Indexes
  @@unique([integrationId, slug], name: "actions_integration_slug_idx")
  @@index([integrationId], name: "actions_integration_id_idx")
  @@map("actions")
}

/// Encrypted credentials for external API connections (OAuth tokens, API keys, etc.)
model IntegrationCredential {
  id                    String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  integrationId         String           @map("integration_id") @db.Uuid
  tenantId              String           @map("tenant_id") @db.Uuid
  connectionId          String?          @map("connection_id") @db.Uuid
  credentialType        CredentialType   @map("credential_type")
  credentialSource      CredentialSource @default(user_owned) @map("credential_source")
  encryptedData         Bytes            @map("encrypted_data")
  expiresAt             DateTime?        @map("expires_at")
  encryptedRefreshToken Bytes?           @map("encrypted_refresh_token")
  scopes                String[]         @default([])
  status                CredentialStatus @default(active)
  createdAt             DateTime         @default(now()) @map("created_at")
  updatedAt             DateTime         @updatedAt @map("updated_at")

  // Relations
  integration Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  tenant      Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  connection  Connection? @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([integrationId], name: "credentials_integration_id_idx")
  @@index([tenantId], name: "credentials_tenant_id_idx")
  @@index([connectionId], name: "credentials_connection_id_idx")
  @@index([credentialSource], name: "credentials_source_idx")
  @@index([expiresAt], name: "credentials_expires_at_idx")
  @@map("integration_credentials")
}

/// Field transformation configuration between Waygate and consuming apps
/// - connectionId = null: Action-level default mapping (applies to all connections)
/// - connectionId set: Connection-specific override (overrides default for that connection)
model FieldMapping {
  id              String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  actionId        String           @map("action_id") @db.Uuid
  tenantId        String?          @map("tenant_id") @db.Uuid
  connectionId    String?          @map("connection_id") @db.Uuid
  sourcePath      String           @map("source_path") @db.VarChar(255)
  targetPath      String           @map("target_path") @db.VarChar(255)
  transformConfig Json?            @map("transform_config")
  direction       MappingDirection
  createdAt       DateTime         @default(now()) @map("created_at")
  updatedAt       DateTime         @updatedAt @map("updated_at")

  // Relations
  action     Action      @relation(fields: [actionId], references: [id], onDelete: Cascade)
  tenant     Tenant?     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  connection Connection? @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  // Indexes and constraints
  // Unique constraint: one mapping per (action, connection, sourcePath, direction)
  // This prevents duplicate mappings for the same source field in the same context
  @@unique([actionId, connectionId, sourcePath, direction], name: "field_mappings_unique_idx")
  @@index([actionId, tenantId], name: "mappings_action_tenant_idx")
  @@index([actionId, connectionId], name: "mappings_action_connection_idx")
  @@map("field_mappings")
}

/// Audit trail for action invocations
model RequestLog {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId        String   @map("tenant_id") @db.Uuid
  integrationId   String   @map("integration_id") @db.Uuid
  actionId        String   @map("action_id") @db.Uuid
  connectionId    String?  @map("connection_id") @db.Uuid
  requestSummary  Json     @map("request_summary")
  responseSummary Json?    @map("response_summary")
  statusCode      Int?     @map("status_code")
  latencyMs       Int      @map("latency_ms")
  retryCount      Int      @default(0) @map("retry_count")
  error           Json?
  createdAt       DateTime @default(now()) @map("created_at")

  // Relations
  tenant      Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  integration Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  action      Action      @relation(fields: [actionId], references: [id], onDelete: Cascade)
  connection  Connection? @relation(fields: [connectionId], references: [id], onDelete: SetNull)

  // Indexes
  @@index([tenantId, createdAt(sort: Desc)], name: "logs_tenant_created_idx")
  @@index([integrationId, createdAt(sort: Desc)], name: "logs_integration_created_idx")
  @@index([actionId, createdAt(sort: Desc)], name: "logs_action_created_idx")
  @@index([connectionId, createdAt(sort: Desc)], name: "logs_connection_created_idx")
  @@map("request_logs")
}

/// Documentation scraping job for creating integrations from API docs
model ScrapeJob {
  id               String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId         String          @map("tenant_id") @db.Uuid
  status           ScrapeJobStatus @default(PENDING)
  documentationUrl String          @map("documentation_url") @db.Text
  specificUrls     String[]        @default([]) @map("specific_urls") // When provided, skips site mapping
  wishlist         String[]        @default([])
  progress         Int             @default(0)
  progressDetails  Json?           @map("progress_details") // Structured progress: {stage, message, pagesFound, pagesScraped, chunksTotal, chunksProcessed, endpointsFound}
  result           Json? // Parsed API structure
  error            Json? // Error details if failed
  cachedContentKey String?         @map("cached_content_key") @db.VarChar(255)
  createdAt        DateTime        @default(now()) @map("created_at")
  updatedAt        DateTime        @updatedAt @map("updated_at")
  completedAt      DateTime?       @map("completed_at")

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([tenantId], name: "scrape_jobs_tenant_id_idx")
  @@index([status], name: "scrape_jobs_status_idx")
  @@index([tenantId, createdAt(sort: Desc)], name: "scrape_jobs_tenant_created_idx")
  @@map("scrape_jobs")
}

/// Tracks validation failures for schema drift detection
model ValidationFailure {
  id               String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  actionId         String    @map("action_id") @db.Uuid
  tenantId         String    @map("tenant_id") @db.Uuid
  issueCode        String    @map("issue_code") @db.VarChar(50)
  fieldPath        String    @map("field_path") @db.VarChar(255)
  expectedType     String?   @map("expected_type") @db.VarChar(50)
  receivedType     String?   @map("received_type") @db.VarChar(50)
  failureCount     Int       @default(1) @map("failure_count")
  firstSeenAt      DateTime  @default(now()) @map("first_seen_at")
  lastSeenAt       DateTime  @default(now()) @map("last_seen_at")
  driftAlertSent   Boolean   @default(false) @map("drift_alert_sent")
  driftAlertSentAt DateTime? @map("drift_alert_sent_at")

  // Relations
  action Action @relation(fields: [actionId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Indexes
  @@unique([actionId, issueCode, fieldPath], name: "validation_failures_unique_idx")
  @@index([actionId], name: "validation_failures_action_idx")
  @@index([tenantId], name: "validation_failures_tenant_idx")
  @@index([lastSeenAt], name: "validation_failures_last_seen_idx")
  @@map("validation_failures")
}

/// Health check results for connections (tiered: credential, connectivity, full_scan)
model HealthCheck {
  id           String             @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  connectionId String             @map("connection_id") @db.Uuid
  tenantId     String             @map("tenant_id") @db.Uuid
  status       HealthCheckStatus // healthy, degraded, unhealthy
  checkTier    HealthCheckTier    @map("check_tier") // credential, connectivity, full_scan
  checkTrigger HealthCheckTrigger @map("check_trigger") // scheduled, manual

  // Credential check results (Tier 1+)
  credentialStatus    CredentialHealthStatus? @map("credential_status") // active, expiring, expired, missing
  credentialExpiresAt DateTime?               @map("credential_expires_at")

  // Test action results (Tier 2+)
  testActionId         String?  @map("test_action_id") @db.Uuid
  testActionSuccess    Boolean? @map("test_action_success")
  testActionLatencyMs  Int?     @map("test_action_latency_ms")
  testActionStatusCode Int?     @map("test_action_status_code")
  testActionError      Json?    @map("test_action_error")

  // Full scan results (Tier 3 only)
  actionsScanned Int?  @map("actions_scanned")
  actionsPassed  Int?  @map("actions_passed")
  actionsFailed  Int?  @map("actions_failed")
  scanResults    Json? @map("scan_results") // Detailed per-action results

  // Circuit breaker status
  circuitBreakerStatus CircuitBreakerStatus? @map("circuit_breaker_status")

  // Overall results
  durationMs Int      @map("duration_ms")
  error      Json?
  createdAt  DateTime @default(now()) @map("created_at")

  // Relations
  connection Connection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  tenant     Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  testAction Action?    @relation("HealthCheckTestAction", fields: [testActionId], references: [id], onDelete: SetNull)

  // Indexes
  @@index([connectionId, createdAt(sort: Desc)], name: "health_checks_connection_created_idx")
  @@index([tenantId, createdAt(sort: Desc)], name: "health_checks_tenant_created_idx")
  @@index([checkTier], name: "health_checks_tier_idx")
  @@index([status], name: "health_checks_status_idx")
  @@map("health_checks")
}

/// Cached reference data from external APIs (users, channels, teams, etc.)
model ReferenceData {
  id            String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId      String  @map("tenant_id") @db.Uuid
  integrationId String  @map("integration_id") @db.Uuid
  connectionId  String? @map("connection_id") @db.Uuid

  dataType   String @map("data_type") @db.VarChar(100) // 'users', 'channels', 'repos', etc.
  externalId String @map("external_id") @db.VarChar(255) // ID from external system
  name       String @db.VarChar(500) // Display name
  metadata   Json   @default("{}") // Flexible additional fields

  status           ReferenceDataStatus @default(active)
  lastSyncedAt     DateTime            @map("last_synced_at")
  syncedByActionId String?             @map("synced_by_action_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  tenant         Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  integration    Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  connection     Connection? @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  syncedByAction Action?     @relation(fields: [syncedByActionId], references: [id], onDelete: SetNull)

  // Indexes
  @@unique([integrationId, connectionId, dataType, externalId], name: "reference_data_unique_idx")
  @@index([tenantId, dataType], name: "reference_data_tenant_type_idx")
  @@index([integrationId, dataType], name: "reference_data_integration_type_idx")
  @@index([connectionId, dataType], name: "reference_data_connection_type_idx")
  @@index([lastSyncedAt], name: "reference_data_last_synced_idx")
  @@index([status], name: "reference_data_status_idx")
  @@map("reference_data")
}

/// Tracks reference data sync jobs
model ReferenceSyncJob {
  id            String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId      String  @map("tenant_id") @db.Uuid
  integrationId String  @map("integration_id") @db.Uuid
  connectionId  String? @map("connection_id") @db.Uuid
  dataType      String  @map("data_type") @db.VarChar(100)

  status      SyncJobStatus @default(pending)
  startedAt   DateTime?     @map("started_at")
  completedAt DateTime?     @map("completed_at")

  itemsFound   Int @default(0) @map("items_found")
  itemsCreated Int @default(0) @map("items_created")
  itemsUpdated Int @default(0) @map("items_updated")
  itemsDeleted Int @default(0) @map("items_deleted")
  itemsFailed  Int @default(0) @map("items_failed")

  error Json? // Error details if failed

  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  tenant      Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  integration Integration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  connection  Connection? @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([integrationId, status], name: "reference_sync_jobs_integration_status_idx")
  @@index([tenantId, createdAt(sort: Desc)], name: "reference_sync_jobs_tenant_created_idx")
  @@index([connectionId, status], name: "reference_sync_jobs_connection_status_idx")
  @@map("reference_sync_jobs")
}

/// Developer-defined variables for dynamic context injection in AI tools
model Variable {
  id           String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId     String  @map("tenant_id") @db.Uuid
  connectionId String? @map("connection_id") @db.Uuid // null = tenant-level, otherwise connection-specific

  key       String       @db.VarChar(100) // Variable name (e.g., "api_version", "default_channel")
  value     Json // Stored value (any type)
  valueType VariableType @default(string) @map("value_type") // string, number, boolean, json

  sensitive      Boolean @default(false) // Encrypt if true
  encryptedValue Bytes?  @map("encrypted_value") // For sensitive vars (AES-256-GCM)
  environment    String? @db.VarChar(50) // null = all, or "development", "staging", "production"

  description String? @db.Text

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  tenant     Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  connection Connection? @relation(fields: [connectionId], references: [id], onDelete: Cascade)

  // Constraints - unique per scope+key+env
  @@unique([tenantId, connectionId, key, environment], name: "variables_unique_idx")
  @@index([tenantId], name: "variables_tenant_idx")
  @@index([connectionId], name: "variables_connection_idx")
  @@map("variables")
}

/// Composite tools - aggregate multiple actions with routing logic
model CompositeTool {
  id                  String                   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId            String                   @map("tenant_id") @db.Uuid
  name                String                   @db.VarChar(255)
  slug                String                   @db.VarChar(100)
  description         String?                  @db.Text
  routingMode         CompositeToolRoutingMode @map("routing_mode")
  defaultOperationId  String?                  @map("default_operation_id") @db.Uuid
  unifiedInputSchema  Json                     @default("{}") @map("unified_input_schema")
  toolDescription     String?                  @map("tool_description") @db.Text /// LLM-optimized mini-prompt description
  toolSuccessTemplate String?                  @map("tool_success_template") @db.Text /// Template for formatting successful responses
  toolErrorTemplate   String?                  @map("tool_error_template") @db.Text /// Template for formatting error responses
  status              CompositeToolStatus      @default(draft)
  metadata            Json                     @default("{}")
  createdAt           DateTime                 @default(now()) @map("created_at")
  updatedAt           DateTime                 @updatedAt @map("updated_at")

  // Relations
  tenant           Tenant                   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  defaultOperation CompositeToolOperation?  @relation("DefaultOperation", fields: [defaultOperationId], references: [id], onDelete: SetNull)
  operations       CompositeToolOperation[] @relation("CompositeToolOperations")
  routingRules     RoutingRule[]

  // Indexes
  @@unique([tenantId, slug], name: "composite_tools_tenant_slug_idx")
  @@index([tenantId], name: "composite_tools_tenant_id_idx")
  @@index([status], name: "composite_tools_status_idx")
  @@map("composite_tools")
}

/// Operations within a composite tool - links to actions with parameter mappings
model CompositeToolOperation {
  id               String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  compositeToolId  String @map("composite_tool_id") @db.Uuid
  actionId         String @map("action_id") @db.Uuid
  operationSlug    String @map("operation_slug") @db.VarChar(100) /// Unique identifier within composite tool
  displayName      String @map("display_name") @db.VarChar(255) /// Human-readable name (e.g., "LinkedIn Scraper")
  parameterMapping Json   @default("{}") @map("parameter_mapping") /// Maps unified params â†’ action params
  priority         Int    @default(0) /// For ordering operations
  createdAt        DateTime @default(now()) @map("created_at")

  // Relations
  compositeTool            CompositeTool @relation("CompositeToolOperations", fields: [compositeToolId], references: [id], onDelete: Cascade)
  action                   Action        @relation(fields: [actionId], references: [id], onDelete: Cascade)
  routingRules             RoutingRule[]
  defaultForCompositeTools CompositeTool[] @relation("DefaultOperation")

  // Indexes
  @@unique([compositeToolId, operationSlug], name: "composite_tool_operations_slug_idx")
  @@unique([compositeToolId, actionId], name: "composite_tool_operations_action_idx")
  @@index([compositeToolId], name: "composite_tool_operations_composite_tool_id_idx")
  @@index([actionId], name: "composite_tool_operations_action_id_idx")
  @@map("composite_tool_operations")
}

/// Routing rules for composite tools - evaluate conditions to select operations
model RoutingRule {
  id              String               @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  compositeToolId String               @map("composite_tool_id") @db.Uuid
  operationId     String               @map("operation_id") @db.Uuid
  conditionType   RoutingConditionType @map("condition_type")
  conditionField  String               @map("condition_field") @db.VarChar(100) /// Input parameter to check (e.g., "url")
  conditionValue  String               @map("condition_value") @db.Text /// Value to compare against
  caseSensitive   Boolean              @default(false) @map("case_sensitive")
  priority        Int                  @default(0) /// Evaluation order (lower = first)
  createdAt       DateTime             @default(now()) @map("created_at")

  // Relations
  compositeTool CompositeTool          @relation(fields: [compositeToolId], references: [id], onDelete: Cascade)
  operation     CompositeToolOperation @relation(fields: [operationId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([compositeToolId, priority], name: "routing_rules_composite_tool_priority_idx")
  @@index([operationId], name: "routing_rules_operation_id_idx")
  @@map("routing_rules")
}

/// Agentic tools - AI tools with embedded LLMs for parameter interpretation or autonomous operation
model AgenticTool {
  id            String                   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId      String                   @map("tenant_id") @db.Uuid
  name          String                   @db.VarChar(255)
  slug          String                   @db.VarChar(100)
  description   String?                  @db.Text
  executionMode AgenticToolExecutionMode @map("execution_mode")

  // Embedded LLM configuration
  // { provider: 'anthropic' | 'google', model: string, reasoningLevel?: string, temperature: number, maxTokens: number, topP?: number }
  embeddedLLMConfig Json @default("{}") @map("embedded_llm_config")

  // System prompt with variable placeholders ({{variable}})
  systemPrompt String @map("system_prompt") @db.Text

  // Tool allocation configuration
  // { mode: 'parameter_interpreter' | 'autonomous_agent', targetActions?: [...], availableTools?: [...] }
  toolAllocation Json @default("{}") @map("tool_allocation")

  // Context configuration for variable injection
  // { variables: { [key]: { type, source?, value? } }, autoInjectSchemas: boolean }
  contextConfig Json @default("{}") @map("context_config")

  // Input schema (parent-facing parameters)
  inputSchema Json @default("{}") @map("input_schema")

  // Parent-facing tool description
  toolDescription String? @map("tool_description") @db.Text

  // Safety limits for autonomous mode
  // { maxToolCalls: number, timeoutSeconds: number, maxTotalCost: number }
  safetyLimits Json @default("{\"maxToolCalls\": 10, \"timeoutSeconds\": 300, \"maxTotalCost\": 1.0}") @map("safety_limits")

  status    AgenticToolStatus @default(draft)
  metadata  Json              @default("{}")
  createdAt DateTime          @default(now()) @map("created_at")
  updatedAt DateTime          @updatedAt @map("updated_at")

  // Relations
  tenant     Tenant                   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  executions AgenticToolExecution[]

  // Indexes
  @@unique([tenantId, slug], name: "agentic_tools_tenant_slug_idx")
  @@index([tenantId], name: "agentic_tools_tenant_id_idx")
  @@index([status], name: "agentic_tools_status_idx")
  @@map("agentic_tools")
}

/// Execution records for agentic tool invocations
model AgenticToolExecution {
  id            String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  agenticToolId String   @map("agentic_tool_id") @db.Uuid
  tenantId      String   @map("tenant_id") @db.Uuid
  parentRequest Json     @map("parent_request") // Original user input
  llmCalls      Json[]   @default([]) @map("llm_calls") // Array of LLM calls with prompts, responses, tokens
  toolCalls     Json[]   @default([]) @map("tool_calls") // Array of tool invocations (Autonomous mode)
  result        Json?    // Final output
  status        AgenticToolExecutionStatus
  error         Json?    // Error details if failed
  totalCost     Decimal  @default(0) @map("total_cost") @db.Decimal(10, 6) // Total LLM cost in USD
  totalTokens   Int      @default(0) @map("total_tokens") // Total tokens used
  durationMs    Int      @default(0) @map("duration_ms")
  traceId       String?  @map("trace_id") @db.VarChar(255) // Langsmith/OTel trace ID
  createdAt     DateTime @default(now()) @map("created_at")
  completedAt   DateTime? @map("completed_at")

  // Relations
  agenticTool AgenticTool @relation(fields: [agenticToolId], references: [id], onDelete: Cascade)
  tenant      Tenant      @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([agenticToolId, createdAt(sort: Desc)], name: "agentic_tool_executions_tool_created_idx")
  @@index([tenantId, createdAt(sort: Desc)], name: "agentic_tool_executions_tenant_created_idx")
  @@index([status], name: "agentic_tool_executions_status_idx")
  @@map("agentic_tool_executions")
}

// =============================================================================
// PIPELINE MODELS
// =============================================================================

/// Pipeline tools - multi-step orchestrated workflows that appear as single tools
model Pipeline {
  id                  String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId            String         @map("tenant_id") @db.Uuid
  name                String         @db.VarChar(255)
  slug                String         @db.VarChar(100)
  description         String?        @db.Text
  inputSchema         Json           @default("{}") @map("input_schema")
  outputMapping       Json           @default("{}") @map("output_mapping")
  toolDescription     String?        @map("tool_description") @db.Text
  toolSuccessTemplate String?        @map("tool_success_template") @db.Text
  toolErrorTemplate   String?        @map("tool_error_template") @db.Text
  safetyLimits        Json           @default("{\"maxCostUsd\": 5, \"maxDurationSeconds\": 1800}") @map("safety_limits")
  reasoningConfig     Json           @default("{}") @map("reasoning_config")
  status              PipelineStatus @default(draft)
  metadata            Json           @default("{}")
  createdAt           DateTime       @default(now()) @map("created_at")
  updatedAt           DateTime       @updatedAt @map("updated_at")

  // Relations
  tenant     Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  steps      PipelineStep[]
  executions PipelineExecution[]

  // Indexes
  @@unique([tenantId, slug], name: "pipelines_tenant_slug_idx")
  @@index([tenantId], name: "pipelines_tenant_id_idx")
  @@index([status], name: "pipelines_status_idx")
  @@map("pipelines")
}

/// Steps within a pipeline - each step optionally invokes a tool with optional LLM reasoning
model PipelineStep {
  id               String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  pipelineId       String                @map("pipeline_id") @db.Uuid
  stepNumber       Int                   @map("step_number")
  name             String                @db.VarChar(255)
  slug             String                @db.VarChar(100)
  toolId           String?               @map("tool_id") @db.Uuid
  toolType         PipelineStepToolType? @map("tool_type")
  toolSlug         String?               @map("tool_slug") @db.VarChar(200)
  inputMapping     Json                  @default("{}") @map("input_mapping")
  onError          StepOnError           @default(fail_pipeline) @map("on_error")
  retryConfig      Json                  @default("{\"maxRetries\": 0, \"backoffMs\": 1000}") @map("retry_config")
  timeoutSeconds   Int                   @default(300) @map("timeout_seconds")
  condition        Json?
  reasoningEnabled Boolean               @default(false) @map("reasoning_enabled")
  reasoningPrompt  String?               @map("reasoning_prompt") @db.Text
  reasoningConfig  Json?                 @map("reasoning_config")
  metadata         Json                  @default("{}")
  createdAt        DateTime              @default(now()) @map("created_at")
  updatedAt        DateTime              @updatedAt @map("updated_at")

  // Relations
  pipeline       Pipeline        @relation(fields: [pipelineId], references: [id], onDelete: Cascade)
  stepExecutions StepExecution[]

  // Indexes
  @@unique([pipelineId, stepNumber], name: "pipeline_steps_pipeline_step_number_idx")
  @@unique([pipelineId, slug], name: "pipeline_steps_pipeline_slug_idx")
  @@index([pipelineId], name: "pipeline_steps_pipeline_id_idx")
  @@map("pipeline_steps")
}

/// Execution records for pipeline invocations
model PipelineExecution {
  id                String                  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  pipelineId        String                  @map("pipeline_id") @db.Uuid
  tenantId          String                  @map("tenant_id") @db.Uuid
  input             Json                    @default("{}")
  state             Json                    @default("{}")
  output            Json?
  status            PipelineExecutionStatus @default(running)
  currentStepNumber Int                     @default(1) @map("current_step_number")
  totalSteps        Int                     @map("total_steps")
  totalCostUsd      Decimal                 @default(0) @map("total_cost_usd") @db.Decimal(10, 6)
  totalTokens       Int                     @default(0) @map("total_tokens")
  error             Json?
  startedAt         DateTime                @default(now()) @map("started_at")
  completedAt       DateTime?               @map("completed_at")
  createdAt         DateTime                @default(now()) @map("created_at")

  // Relations
  tenant         Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  pipeline       Pipeline        @relation(fields: [pipelineId], references: [id], onDelete: Cascade)
  stepExecutions StepExecution[]

  // Indexes
  @@index([pipelineId, createdAt(sort: Desc)], name: "pipeline_executions_pipeline_created_idx")
  @@index([tenantId, createdAt(sort: Desc)], name: "pipeline_executions_tenant_created_idx")
  @@index([status], name: "pipeline_executions_status_idx")
  @@map("pipeline_executions")
}

/// Execution records for individual steps within a pipeline execution
model StepExecution {
  id                  String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  pipelineExecutionId String              @map("pipeline_execution_id") @db.Uuid
  pipelineStepId      String              @map("pipeline_step_id") @db.Uuid
  stepNumber          Int                 @map("step_number")
  status              StepExecutionStatus @default(pending)
  resolvedInput       Json?               @map("resolved_input")
  toolOutput          Json?               @map("tool_output")
  reasoningOutput     Json?               @map("reasoning_output")
  error               Json?
  retryCount          Int                 @default(0) @map("retry_count")
  costUsd             Decimal             @default(0) @map("cost_usd") @db.Decimal(10, 6)
  tokensUsed          Int                 @default(0) @map("tokens_used")
  durationMs          Int                 @default(0) @map("duration_ms")
  startedAt           DateTime?           @map("started_at")
  completedAt         DateTime?           @map("completed_at")
  createdAt           DateTime            @default(now()) @map("created_at")

  // Relations
  pipelineExecution PipelineExecution @relation(fields: [pipelineExecutionId], references: [id], onDelete: Cascade)
  pipelineStep      PipelineStep      @relation(fields: [pipelineStepId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([pipelineExecutionId, stepNumber], name: "step_executions_execution_step_idx")
  @@index([pipelineStepId], name: "step_executions_step_id_idx")
  @@index([status], name: "step_executions_status_idx")
  @@map("step_executions")
}

// =============================================================================
// ASYNC JOB MODELS
// =============================================================================

/// Generic async job for background processing (batch ops, schema drift, scraping, etc.)
model AsyncJob {
  id              String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  tenantId        String?   @map("tenant_id") @db.Uuid
  type            String    // e.g., "batch_operation", "schema_drift", "scrape"
  status          String    @default("queued") // queued, running, completed, failed, cancelled
  input           Json?     // Job-specific input parameters (sanitized)
  output          Json?     // Job result on completion
  error           Json?     // Error details on failure
  progress        Int       @default(0) // 0-100
  progressDetails Json?     @map("progress_details") // Stage-specific details
  attempts        Int       @default(0)
  maxAttempts     Int       @default(3) @map("max_attempts")
  timeoutSeconds  Int       @default(300) @map("timeout_seconds") // Per-job-type timeout
  nextRunAt       DateTime? @map("next_run_at") @db.Timestamptz // For retry backoff scheduling
  startedAt       DateTime? @map("started_at") @db.Timestamptz
  completedAt     DateTime? @map("completed_at") @db.Timestamptz
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz
  updatedAt       DateTime  @updatedAt @map("updated_at") @db.Timestamptz

  // Relations
  tenant Tenant?      @relation(fields: [tenantId], references: [id])
  items  AsyncJobItem[]

  // Indexes
  @@index([tenantId, createdAt(sort: Desc)], map: "async_jobs_tenant_created_idx")
  @@index([type, status], map: "async_jobs_type_status_idx")
  @@index([status, nextRunAt], map: "async_jobs_status_next_run_idx")
  @@map("async_jobs")
}

/// Individual items within a batch async job
model AsyncJobItem {
  id          String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  jobId       String    @map("job_id") @db.Uuid
  status      String    @default("pending") // pending, running, completed, failed, skipped
  input       Json?     // Item-specific input
  output      Json?     // Item result
  error       Json?     // Item error details
  attempts    Int       @default(0)
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz
  completedAt DateTime? @map("completed_at") @db.Timestamptz

  // Relations
  job AsyncJob @relation(fields: [jobId], references: [id], onDelete: Cascade)

  // Indexes
  @@index([jobId, status], map: "async_job_items_job_status_idx")
  @@map("async_job_items")
}
